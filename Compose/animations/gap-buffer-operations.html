<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gap Buffer 复杂操作演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Monaco', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            background: #0f0f23;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            padding: 30px;
            max-width: 1400px;
            margin: 0 auto;
            border: 1px solid #333;
        }

        h2 {
            text-align: center;
            color: #00d9ff;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .scenario-selector {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .scenario-btn {
            padding: 10px 20px;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #1a1a2e;
            color: #aaa;
        }

        .scenario-btn:hover {
            border-color: #00d9ff;
            color: #00d9ff;
        }

        .scenario-btn.active {
            background: linear-gradient(135deg, #00d9ff 0%, #0099ff 100%);
            color: #000;
            border-color: #00d9ff;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #1a1a2e;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #333;
        }

        .panel-title {
            font-size: 14px;
            font-weight: bold;
            color: #00d9ff;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title::before {
            content: '';
            width: 4px;
            height: 16px;
            background: #00d9ff;
            border-radius: 2px;
        }

        /* 代码面板 */
        .code-container {
            background: #0d1117;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.8;
            overflow-x: auto;
            max-height: 350px;
            overflow-y: auto;
        }

        .code-line {
            display: flex;
            padding: 2px 0;
            transition: background 0.3s ease;
        }

        .code-line.highlight {
            background: rgba(0, 217, 255, 0.15);
            border-left: 3px solid #00d9ff;
            margin-left: -15px;
            padding-left: 12px;
        }

        .code-line.executed {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
            margin-left: -15px;
            padding-left: 12px;
        }

        .line-num {
            color: #555;
            width: 30px;
            text-align: right;
            margin-right: 15px;
            user-select: none;
        }

        .code-content {
            color: #e6e6e6;
            white-space: pre;
        }

        .kw { color: #ff79c6; }
        .fn { color: #50fa7b; }
        .cm { color: #6272a4; }
        .str { color: #f1fa8c; }
        .num { color: #bd93f9; }
        .var { color: #8be9fd; }
        .op { color: #ff79c6; }

        /* 数组可视化 */
        .array-viz {
            margin-bottom: 20px;
        }

        .array-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .array-label .vars {
            font-family: 'Monaco', monospace;
            color: #00d9ff;
        }

        .array-row {
            display: flex;
            gap: 3px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: flex-start;
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Monaco', monospace;
            font-size: 14px;
            font-weight: bold;
            background: #1a1a2e;
            position: relative;
            transition: all 0.4s ease;
        }

        .cell .index {
            position: absolute;
            top: -18px;
            font-size: 10px;
            color: #555;
            font-weight: normal;
        }

        .cell.gap {
            background: linear-gradient(135deg, #ff6b6b33 0%, #feca5733 100%);
            border-color: #ff6b6b;
            color: #ff6b6b;
            font-size: 10px;
        }

        .cell.data {
            color: #00ff88;
            border-color: #00ff8855;
        }

        .cell.highlight {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
            border-color: #00d9ff;
            z-index: 10;
        }

        .cell.inserting {
            animation: insertPulse 0.6s ease;
            background: linear-gradient(135deg, #00ff8833 0%, #00d9ff33 100%);
            border-color: #00ff88;
        }

        .cell.deleting {
            animation: deletePulse 0.6s ease;
            background: linear-gradient(135deg, #ff6b6b33 0%, #ff006633 100%);
            border-color: #ff6b6b;
        }

        .cell.moving {
            animation: movePulse 0.6s ease;
            background: linear-gradient(135deg, #feca5733 0%, #ff990033 100%);
            border-color: #feca57;
        }

        @keyframes insertPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        @keyframes deletePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes movePulse {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        /* 状态说明 */
        .state-panel {
            background: #0d1117;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .state-title {
            font-size: 13px;
            color: #00d9ff;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .state-desc {
            color: #aaa;
            font-size: 13px;
            line-height: 1.6;
        }

        .state-desc code {
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            color: #00ff88;
            font-family: 'Monaco', monospace;
        }

        /* 控制栏 */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .ctrl-btn {
            padding: 10px 25px;
            border: 2px solid #00d9ff;
            border-radius: 8px;
            background: transparent;
            color: #00d9ff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .ctrl-btn:hover {
            background: #00d9ff;
            color: #000;
        }

        .ctrl-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* 步骤指示器 */
        .step-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 20px;
        }

        .step-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s ease;
        }

        .step-dot.active {
            background: #00d9ff;
            transform: scale(1.3);
        }

        .step-dot.done {
            background: #00ff88;
        }

        /* 执行顺序提示 */
        .exec-order {
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            background: #00d9ff;
            color: #000;
            border-radius: 50%;
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 1100px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Gap Buffer 复杂操作演示</h2>
        <p class="subtitle">展示 SlotWriter 如何使用 Gap Buffer 处理重组场景中的复杂操作</p>

        <div class="scenario-selector">
            <button class="scenario-btn active" onclick="loadScenario('insertMiddle')">场景1: 中间插入</button>
            <button class="scenario-btn" onclick="loadScenario('deleteRange')">场景2: 批量删除</button>
            <button class="scenario-btn" onclick="loadScenario('moveAndInsert')">场景3: 移动后插入</button>
        </div>

        <div class="main-layout">
            <!-- 左侧：代码面板 -->
            <div class="panel">
                <div class="panel-title">SlotWriter 代码执行</div>
                <div class="code-container" id="codePanel">
                    <!-- 代码将动态生成 -->
                </div>
            </div>

            <!-- 右侧：可视化面板 -->
            <div class="panel">
                <div class="panel-title">Gap Buffer 状态变化</div>

                <div class="array-viz">
                    <div class="array-label">
                        <span>groups 数组</span>
                        <span class="vars" id="groupsVars">gapStart=2, gapLen=3</span>
                    </div>
                    <div class="array-row" id="groupsArray">
                        <!-- 数组将动态生成 -->
                    </div>
                </div>

                <div class="array-viz">
                    <div class="array-label">
                        <span>slots 数组</span>
                        <span class="vars" id="slotsVars">slotsGapStart=4, slotsGapLen=4</span>
                    </div>
                    <div class="array-row" id="slotsArray">
                        <!-- 数组将动态生成 -->
                    </div>
                </div>

                <div class="state-panel">
                    <div class="state-title" id="stepTitle">当前步骤</div>
                    <div class="state-desc" id="stepDesc">选择一个场景开始演示</div>
                </div>
            </div>
        </div>

        <div class="step-indicator" id="stepIndicator">
            <!-- 步骤点将动态生成 -->
        </div>

        <div class="controls">
            <button class="ctrl-btn" onclick="prevStep()" id="prevBtn">◀ 上一步</button>
            <button class="ctrl-btn" onclick="nextStep()" id="nextBtn">下一步 ▶</button>
            <button class="ctrl-btn" onclick="resetScenario()">↺ 重置</button>
            <button class="ctrl-btn" onclick="autoPlay()" id="autoBtn">▶ 自动播放</button>
        </div>
    </div>

    <script>
        let currentScenario = 'insertMiddle';
        let currentStep = 0;
        let autoPlayTimer = null;

        // 场景定义
        const scenarios = {
            // 场景1: 在中间位置插入新 Group（需要先移动 Gap）
            insertMiddle: {
                title: '场景1: 在中间位置插入新 Group',
                desc: '当需要在非 Gap 位置插入数据时，必须先移动 Gap 到目标位置',
                code: [
                    { text: '// 场景：在索引 1 处插入新 Group', type: 'cm' },
                    { text: '// 当前 gap 在索引 4，需要先移动', type: 'cm' },
                    { text: '' },
                    { text: 'fun insertGroupAt(index: Int) {', type: 'fn' },
                    { text: '    // 步骤1: 移动 gap 到目标位置', type: 'cm' },
                    { text: '    moveGroupGapTo(index)', type: 'exec', execOrder: 1 },
                    { text: '' },
                    { text: '    // 步骤2: 在 gap 起始位置写入数据', type: 'cm' },
                    { text: '    groups[gapStart * 5 + Key] = key', type: 'exec', execOrder: 2 },
                    { text: '    groups[gapStart * 5 + Info] = info', type: 'exec', execOrder: 2 },
                    { text: '' },
                    { text: '    // 步骤3: 更新 gap 指针', type: 'cm' },
                    { text: '    gapStart++', type: 'exec', execOrder: 3 },
                    { text: '    gapLen--', type: 'exec', execOrder: 3 },
                    { text: '}' },
                    { text: '' },
                    { text: 'private fun moveGroupGapTo(index: Int) {', type: 'fn' },
                    { text: '    if (index < gapStart) {', type: 'code' },
                    { text: '        // gap 向前移动：复制 [index, gapStart) 到 gap 后', type: 'cm' },
                    { text: '        val count = gapStart - index', type: 'code' },
                    { text: '        groups.copyInto(', type: 'exec', execOrder: 1 },
                    { text: '            groups,', type: 'exec', execOrder: 1 },
                    { text: '            destinationOffset = (index + gapLen) * 5,', type: 'exec', execOrder: 1 },
                    { text: '            startIndex = index * 5,', type: 'exec', execOrder: 1 },
                    { text: '            endIndex = gapStart * 5', type: 'exec', execOrder: 1 },
                    { text: '        )', type: 'exec', execOrder: 1 },
                    { text: '        gapStart = index', type: 'exec', execOrder: 1 },
                    { text: '    }', type: 'code' },
                    { text: '}' },
                ],
                steps: [
                    {
                        title: '初始状态',
                        desc: '当前 <code>gapStart=4</code>, <code>gapLen=2</code>。需要在索引 1 处插入新 Group "X"。',
                        groups: { data: ['G0', 'G1', 'G2', 'G3', '', '', 'G4', 'G5'], gapStart: 4, gapLen: 2 },
                        slots: { data: ['s0', 's1', 's2', 's3', '', '', '', '', 's4', 's5'], gapStart: 4, gapLen: 4 },
                        highlightLines: [0, 1],
                        highlightCells: { groups: [1], slots: [] }
                    },
                    {
                        title: '步骤1: 计算需要移动的数据',
                        desc: '目标索引 1 < gapStart 4，需要将 <code>[1, 4)</code> 共 3 个元素复制到 gap 后面。',
                        groups: { data: ['G0', 'G1', 'G2', 'G3', '', '', 'G4', 'G5'], gapStart: 4, gapLen: 2 },
                        slots: { data: ['s0', 's1', 's2', 's3', '', '', '', '', 's4', 's5'], gapStart: 4, gapLen: 4 },
                        highlightLines: [17, 18, 19],
                        highlightCells: { groups: [1, 2, 3], slots: [] },
                        cellClass: { groups: { 1: 'moving', 2: 'moving', 3: 'moving' } }
                    },
                    {
                        title: '步骤2: 执行 copyInto 操作',
                        desc: '将 G1、G2、G3 复制到索引 <code>1 + 2 = 3</code> 开始的位置。',
                        groups: { data: ['G0', '', '', 'G1', 'G2', 'G3', 'G4', 'G5'], gapStart: 1, gapLen: 2 },
                        slots: { data: ['s0', 's1', 's2', 's3', '', '', '', '', 's4', 's5'], gapStart: 4, gapLen: 4 },
                        highlightLines: [20, 21, 22, 23, 24, 25, 26],
                        highlightCells: { groups: [1, 2], slots: [] }
                    },
                    {
                        title: '步骤3: 在 gap 位置写入新数据',
                        desc: '现在 gap 在索引 1，直接写入新 Group "X" 的数据。',
                        groups: { data: ['G0', 'X', '', 'G1', 'G2', 'G3', 'G4', 'G5'], gapStart: 2, gapLen: 1 },
                        slots: { data: ['s0', 's1', 's2', 's3', '', '', '', '', 's4', 's5'], gapStart: 4, gapLen: 4 },
                        highlightLines: [8, 9],
                        highlightCells: { groups: [1], slots: [] },
                        cellClass: { groups: { 1: 'inserting' } }
                    },
                    {
                        title: '完成: Gap 指针已更新',
                        desc: '插入完成！<code>gapStart=2</code>, <code>gapLen=1</code>。整个操作 O(n) 复杂度来自数据移动。',
                        groups: { data: ['G0', 'X', '', 'G1', 'G2', 'G3', 'G4', 'G5'], gapStart: 2, gapLen: 1 },
                        slots: { data: ['s0', 's1', 's2', 's3', '', '', '', '', 's4', 's5'], gapStart: 4, gapLen: 4 },
                        highlightLines: [12, 13],
                        highlightCells: { groups: [1], slots: [] }
                    }
                ]
            },

            // 场景2: 批量删除多个 Group
            deleteRange: {
                title: '场景2: 批量删除多个 Group',
                desc: '删除操作通过扩展 Gap 来"吞入"要删除的数据，实现 O(1) 删除',
                code: [
                    { text: '// 场景：删除索引 2-3 的两个 Group', type: 'cm' },
                    { text: '// 删除 = 将数据"吞入" gap', type: 'cm' },
                    { text: '' },
                    { text: 'fun removeGroups(start: Int, count: Int) {', type: 'fn' },
                    { text: '    // 步骤1: 移动 gap 到删除位置的末尾', type: 'cm' },
                    { text: '    moveGroupGapTo(start + count)', type: 'exec', execOrder: 1 },
                    { text: '' },
                    { text: '    // 步骤2: 向前扩展 gap，吞入要删除的数据', type: 'cm' },
                    { text: '    gapStart -= count  // gap 起点前移', type: 'exec', execOrder: 2 },
                    { text: '    gapLen += count    // gap 长度增加', type: 'exec', execOrder: 2 },
                    { text: '' },
                    { text: '    // 步骤3: 更新 groupsSize', type: 'cm' },
                    { text: '    groupsSize -= count', type: 'exec', execOrder: 3 },
                    { text: '' },
                    { text: '    // 被删除的数据仍在数组中，', type: 'cm' },
                    { text: '    // 但已被标记为 gap，后续会被覆盖', type: 'cm' },
                    { text: '}' },
                ],
                steps: [
                    {
                        title: '初始状态',
                        desc: '需要删除索引 2 和 3 的 Group（G2 和 G3）。当前 <code>gapStart=6</code>, <code>gapLen=2</code>。',
                        groups: { data: ['G0', 'G1', 'G2', 'G3', 'G4', 'G5', '', ''], gapStart: 6, gapLen: 2 },
                        slots: { data: ['s0', 's1', 's2', 's3', 's4', 's5', '', '', '', ''], gapStart: 6, gapLen: 4 },
                        highlightLines: [0, 1],
                        highlightCells: { groups: [2, 3], slots: [2, 3] },
                        cellClass: { groups: { 2: 'deleting', 3: 'deleting' } }
                    },
                    {
                        title: '步骤1: 移动 gap 到删除位置末尾',
                        desc: '调用 <code>moveGroupGapTo(4)</code>，将 gap 移动到索引 4（删除范围的末尾）。',
                        groups: { data: ['G0', 'G1', 'G2', 'G3', '', '', 'G4', 'G5'], gapStart: 4, gapLen: 2 },
                        slots: { data: ['s0', 's1', 's2', 's3', '', '', '', '', 's4', 's5'], gapStart: 4, gapLen: 4 },
                        highlightLines: [5],
                        highlightCells: { groups: [4, 5], slots: [] },
                        cellClass: { groups: { 6: 'moving', 7: 'moving' } }
                    },
                    {
                        title: '步骤2: 扩展 gap 吞入删除数据',
                        desc: '<code>gapStart -= 2</code> 将 gap 起点从 4 移到 2，<code>gapLen += 2</code> 将长度从 2 增到 4。',
                        groups: { data: ['G0', 'G1', '', '', '', '', 'G4', 'G5'], gapStart: 2, gapLen: 4 },
                        slots: { data: ['s0', 's1', '', '', '', '', '', '', 's4', 's5'], gapStart: 2, gapLen: 6 },
                        highlightLines: [8, 9],
                        highlightCells: { groups: [2, 3, 4, 5], slots: [2, 3, 4, 5, 6, 7] }
                    },
                    {
                        title: '完成: 删除操作 O(1)',
                        desc: 'G2、G3 被 gap 覆盖，逻辑上已删除。数据仍在数组中但不可访问。<code>groupsSize</code> 更新为 4。',
                        groups: { data: ['G0', 'G1', '', '', '', '', 'G4', 'G5'], gapStart: 2, gapLen: 4 },
                        slots: { data: ['s0', 's1', '', '', '', '', '', '', 's4', 's5'], gapStart: 2, gapLen: 6 },
                        highlightLines: [12, 14, 15],
                        highlightCells: { groups: [], slots: [] }
                    }
                ]
            },

            // 场景3: 移动 Gap 后连续插入
            moveAndInsert: {
                title: '场景3: 移动 Gap 后连续插入',
                desc: '展示 Gap Buffer 的核心优势：一次移动后，连续插入都是 O(1)',
                code: [
                    { text: '// 场景：在索引 2 处连续插入 3 个 Group', type: 'cm' },
                    { text: '// 展示 Gap Buffer 的局部性优势', type: 'cm' },
                    { text: '' },
                    { text: 'fun insertMultiple(index: Int, items: List) {', type: 'fn' },
                    { text: '    // 步骤1: 一次性移动 gap 到目标位置', type: 'cm' },
                    { text: '    moveGroupGapTo(index)  // O(n)', type: 'exec', execOrder: 1 },
                    { text: '' },
                    { text: '    // 步骤2: 连续插入，每次 O(1)', type: 'cm' },
                    { text: '    for (item in items) {', type: 'code' },
                    { text: '        groups[gapStart * 5] = item.key', type: 'exec', execOrder: 2 },
                    { text: '        gapStart++', type: 'exec', execOrder: 2 },
                    { text: '        gapLen--', type: 'exec', execOrder: 2 },
                    { text: '    }', type: 'code' },
                    { text: '' },
                    { text: '    // 总复杂度: O(n) + O(k) = O(n)', type: 'cm' },
                    { text: '    // 其中 n 是移动距离，k 是插入数量', type: 'cm' },
                    { text: '}' },
                ],
                steps: [
                    {
                        title: '初始状态',
                        desc: '需要在索引 2 处插入 X、Y、Z 三个 Group。当前 gap 在末尾。',
                        groups: { data: ['G0', 'G1', 'G2', 'G3', '', '', '', ''], gapStart: 4, gapLen: 4 },
                        slots: { data: ['s0', 's1', 's2', 's3', '', '', '', '', '', ''], gapStart: 4, gapLen: 6 },
                        highlightLines: [0, 1],
                        highlightCells: { groups: [2], slots: [] }
                    },
                    {
                        title: '步骤1: 移动 gap 到索引 2',
                        desc: '将 G2、G3 向后移动，gap 移到索引 2。这是唯一的 O(n) 操作。',
                        groups: { data: ['G0', 'G1', '', '', '', '', 'G2', 'G3'], gapStart: 2, gapLen: 4 },
                        slots: { data: ['s0', 's1', '', '', '', '', '', '', 's2', 's3'], gapStart: 2, gapLen: 6 },
                        highlightLines: [5],
                        highlightCells: { groups: [2, 3, 4, 5], slots: [] },
                        cellClass: { groups: { 6: 'moving', 7: 'moving' } }
                    },
                    {
                        title: '步骤2a: 插入第一个元素 X',
                        desc: '在 <code>gapStart=2</code> 写入 X，然后 <code>gapStart++</code>。O(1) 操作！',
                        groups: { data: ['G0', 'G1', 'X', '', '', '', 'G2', 'G3'], gapStart: 3, gapLen: 3 },
                        slots: { data: ['s0', 's1', 'sX', '', '', '', '', '', 's2', 's3'], gapStart: 3, gapLen: 5 },
                        highlightLines: [9, 10, 11],
                        highlightCells: { groups: [2], slots: [2] },
                        cellClass: { groups: { 2: 'inserting' }, slots: { 2: 'inserting' } }
                    },
                    {
                        title: '步骤2b: 插入第二个元素 Y',
                        desc: '继续在 <code>gapStart=3</code> 写入 Y。无需移动任何数据！',
                        groups: { data: ['G0', 'G1', 'X', 'Y', '', '', 'G2', 'G3'], gapStart: 4, gapLen: 2 },
                        slots: { data: ['s0', 's1', 'sX', 'sY', '', '', '', '', 's2', 's3'], gapStart: 4, gapLen: 4 },
                        highlightLines: [9, 10, 11],
                        highlightCells: { groups: [3], slots: [3] },
                        cellClass: { groups: { 3: 'inserting' }, slots: { 3: 'inserting' } }
                    },
                    {
                        title: '步骤2c: 插入第三个元素 Z',
                        desc: '继续在 <code>gapStart=4</code> 写入 Z。三次插入，只移动了一次数据！',
                        groups: { data: ['G0', 'G1', 'X', 'Y', 'Z', '', 'G2', 'G3'], gapStart: 5, gapLen: 1 },
                        slots: { data: ['s0', 's1', 'sX', 'sY', 'sZ', '', '', '', 's2', 's3'], gapStart: 5, gapLen: 3 },
                        highlightLines: [9, 10, 11],
                        highlightCells: { groups: [4], slots: [4] },
                        cellClass: { groups: { 4: 'inserting' }, slots: { 4: 'inserting' } }
                    },
                    {
                        title: '完成: Gap Buffer 的局部性优势',
                        desc: '3 次插入只需 1 次数据移动。如果没有 Gap Buffer，每次插入都要移动后面所有数据！',
                        groups: { data: ['G0', 'G1', 'X', 'Y', 'Z', '', 'G2', 'G3'], gapStart: 5, gapLen: 1 },
                        slots: { data: ['s0', 's1', 'sX', 'sY', 'sZ', '', '', '', 's2', 's3'], gapStart: 5, gapLen: 3 },
                        highlightLines: [14, 15],
                        highlightCells: { groups: [2, 3, 4], slots: [2, 3, 4] }
                    }
                ]
            }
        };

        function renderCode(scenario) {
            const container = document.getElementById('codePanel');
            const step = scenario.steps[currentStep];
            const highlightLines = step.highlightLines || [];

            let html = '';
            scenario.code.forEach((line, idx) => {
                const isHighlight = highlightLines.includes(idx);
                const lineClass = isHighlight ? 'code-line highlight' : 'code-line';

                let content = line.text;
                // 语法高亮
                content = content.replace(/\/\/.*/g, '<span class="cm">$&</span>');
                content = content.replace(/\b(fun|val|var|if|for|in|return|private)\b/g, '<span class="kw">$1</span>');
                content = content.replace(/\b(moveGroupGapTo|copyInto|removeGroups|insertMultiple|insertGroupAt)\b/g, '<span class="fn">$1</span>');
                content = content.replace(/\b(\d+)\b/g, '<span class="num">$1</span>');
                content = content.replace(/\b(gapStart|gapLen|groupsSize|groups|index|count|start|items|item)\b/g, '<span class="var">$1</span>');

                html += `<div class="${lineClass}">
                    <span class="line-num">${idx + 1}</span>
                    <span class="code-content">${content}</span>
                </div>`;
            });

            container.innerHTML = html;
        }

        function renderArray(containerId, varsId, arrayData, label) {
            const container = document.getElementById(containerId);
            const varsSpan = document.getElementById(varsId);
            const step = scenarios[currentScenario].steps[currentStep];
            const { data, gapStart, gapLen } = arrayData;
            const highlightCells = step.highlightCells?.[containerId.replace('Array', '')] || [];
            const cellClasses = step.cellClass?.[containerId.replace('Array', '')] || {};

            varsSpan.textContent = `gapStart=${gapStart}, gapLen=${gapLen}`;

            let html = '';
            data.forEach((value, idx) => {
                const isGap = idx >= gapStart && idx < gapStart + gapLen;
                const isHighlight = highlightCells.includes(idx);
                const extraClass = cellClasses[idx] || '';

                let cellClass = 'cell';
                if (isGap) cellClass += ' gap';
                else cellClass += ' data';
                if (isHighlight) cellClass += ' highlight';
                if (extraClass) cellClass += ' ' + extraClass;

                html += `<div class="${cellClass}">
                    <span class="index">${idx}</span>
                    ${isGap ? 'GAP' : value}
                </div>`;
            });

            container.innerHTML = html;
        }

        function renderStepIndicator() {
            const container = document.getElementById('stepIndicator');
            const steps = scenarios[currentScenario].steps;

            let html = '';
            steps.forEach((_, idx) => {
                let dotClass = 'step-dot';
                if (idx < currentStep) dotClass += ' done';
                if (idx === currentStep) dotClass += ' active';
                html += `<div class="${dotClass}"></div>`;
            });

            container.innerHTML = html;
        }

        function renderState() {
            const step = scenarios[currentScenario].steps[currentStep];
            document.getElementById('stepTitle').textContent = step.title;
            document.getElementById('stepDesc').innerHTML = step.desc;
        }

        function render() {
            const scenario = scenarios[currentScenario];
            const step = scenario.steps[currentStep];

            renderCode(scenario);
            renderArray('groupsArray', 'groupsVars', step.groups, 'groups');
            renderArray('slotsArray', 'slotsVars', step.slots, 'slots');
            renderStepIndicator();
            renderState();

            // 更新按钮状态
            document.getElementById('prevBtn').disabled = currentStep === 0;
            document.getElementById('nextBtn').disabled = currentStep === scenario.steps.length - 1;
        }

        function loadScenario(name) {
            currentScenario = name;
            currentStep = 0;
            stopAutoPlay();

            // 更新按钮状态
            document.querySelectorAll('.scenario-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            render();
        }

        function nextStep() {
            const steps = scenarios[currentScenario].steps;
            if (currentStep < steps.length - 1) {
                currentStep++;
                render();
            } else {
                stopAutoPlay();
            }
        }

        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                render();
            }
        }

        function resetScenario() {
            currentStep = 0;
            stopAutoPlay();
            render();
        }

        function autoPlay() {
            if (autoPlayTimer) {
                stopAutoPlay();
            } else {
                document.getElementById('autoBtn').textContent = '⏸ 暂停';
                autoPlayTimer = setInterval(() => {
                    const steps = scenarios[currentScenario].steps;
                    if (currentStep < steps.length - 1) {
                        currentStep++;
                        render();
                    } else {
                        stopAutoPlay();
                    }
                }, 1500);
            }
        }

        function stopAutoPlay() {
            if (autoPlayTimer) {
                clearInterval(autoPlayTimer);
                autoPlayTimer = null;
                document.getElementById('autoBtn').textContent = '▶ 自动播放';
            }
        }

        // 初始化
        render();
    </script>
</body>
</html>
